var documenterSearchIndex = {"docs":
[{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FillArrays allows one to lazily represent arrays filled with a single entry, as well as identity matrices. This package exports the following types: Eye, Fill, Ones, Zeros, Trues and Falses. Among these, the FillArrays.AbstractFill types represent lazy versions of dense arrays where all elements have the same value. Eye, on the other hand, represents a Diagonal matrix with ones along the principal diagonal. All these types accept sizes or axes as arguments, so one may create arrays of arbitrary sizes and dimensions. A rectangular Eye matrix may be constructed analogously, by passing the size of the matrix to Eye.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Create a 2x2 zero matrix","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> z = Zeros(2,2)\n2×2 Zeros{Float64}\n\njulia> Array(z)\n2×2 Matrix{Float64}:\n 0.0  0.0\n 0.0  0.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"We may specify the element type as","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> z = Zeros{Int}(2,2)\n2×2 Zeros{Int64}\n\njulia> Array(z)\n2×2 Matrix{Int64}:\n 0  0\n 0  0","category":"page"},{"location":"","page":"Home","title":"Home","text":"We may create arrays with any number of dimensions. A Vector of ones may be created as","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> a = Ones(4)\n4-element Ones{Float64}\n\njulia> Array(a)\n4-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n 1.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"Similarly, a 2x3x2 array, where every element is equal to 10, may be created as","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> f = Fill(10, 2,3,2)\n2×3×2 Fill{Int64}, with entries equal to 10\n\njulia> Array(f)\n2×3×2 Array{Int64, 3}:\n[:, :, 1] =\n 10  10  10\n 10  10  10\n\n[:, :, 2] =\n 10  10  10\n 10  10  10","category":"page"},{"location":"","page":"Home","title":"Home","text":"The elements of a Fill array don't need to be restricted to numbers, and these may be any Julia object. For example, we may construct an array of strings using","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> f = Fill(\"hello\", 2,5)\n2×5 Fill{String}, with entries equal to \"hello\"\n\njulia> Array(f)\n2×5 Matrix{String}:\n \"hello\"  \"hello\"  \"hello\"  \"hello\"  \"hello\"\n \"hello\"  \"hello\"  \"hello\"  \"hello\"  \"hello\"","category":"page"},{"location":"#Conversion-to-a-sparse-form","page":"Home","title":"Conversion to a sparse form","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These Fill array types may be converted to sparse arrays as well, which might be useful in certain cases","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using SparseArrays\n\njulia> z = Zeros{Int}(2,2)\n2×2 Zeros{Int64}\n\njulia> sparse(z)\n2×2 SparseMatrixCSC{Int64, Int64} with 0 stored entries:\n ⋅  ⋅\n ⋅  ⋅","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note, however, that most Fill arrays are not sparse, despite being lazily evaluated.","category":"page"},{"location":"","page":"Home","title":"Home","text":"These types have methods that perform many operations efficiently, including elementary algebra operations like multiplication and addition, as well as linear algebra methods like norm, adjoint, transpose and vec.","category":"page"},{"location":"#Custom-axes","page":"Home","title":"Custom axes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The various Fill equivalents all support offset or custom axes, where instead of the size, one may pass a Tuple of axes. So, for example, one may use a SOneTo axis from StaticArrays.jl to construct a statically sized Fill.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using StaticArrays\n\njulia> f = Fill(2, (SOneTo(4), SOneTo(5)))\n4×5 Fill{Int64, 2, Tuple{SOneTo{4}, SOneTo{5}}} with indices SOneTo(4)×SOneTo(5), with entries equal to 2","category":"page"},{"location":"","page":"Home","title":"Home","text":"The size of such an array would be known at compile time, permitting compiler optimizations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We may construct infinite fill arrays by passing infinite-sized axes, see InfiniteArrays.jl.","category":"page"},{"location":"#Other-lazy-types","page":"Home","title":"Other lazy types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A lazy representation of an identity matrix may be constructured using Eye. For example, a 4x4 identity matrix with Float32 elements may be constructed as","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> id = Eye{Float32}(4)\n4×4 Eye{Float32}\n\njulia> Array(id)\n4×4 Matrix{Float32}:\n 1.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  1.0\n\njulia> sparse(id)\n4×4 SparseMatrixCSC{Float32, Int64} with 4 stored entries:\n 1.0   ⋅    ⋅    ⋅\n  ⋅   1.0   ⋅    ⋅\n  ⋅    ⋅   1.0   ⋅\n  ⋅    ⋅    ⋅   1.0\n\njulia> idrect = Eye(2,5) # rectangular matrix\n2×5 Eye{Float64}\n\njulia> sparse(idrect)\n2×5 SparseMatrixCSC{Float64, Int64} with 2 stored entries:\n 1.0   ⋅    ⋅    ⋅    ⋅\n  ⋅   1.0   ⋅    ⋅    ⋅","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that an Eye actually returns a Diagonal matrix, where the diagonal is a Ones vector.","category":"page"},{"location":"#Warning-about-map-and-broadcasting","page":"Home","title":"Warning about map and broadcasting","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Broadcasting operations, and map and mapreduce, are also done efficiently, by evaluating the function being applied only once:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> map(sqrt, Fill(4, 2,5))  # one evaluation, not 10, to save time\n2×5 Fill{Float64}, with entries equal to 2.0\n\njulia> println.(Fill(pi, 10))\nπ\n10-element Fill{Nothing}, with entries equal to nothing","category":"page"},{"location":"","page":"Home","title":"Home","text":"Notice that this will only match the behaviour of a dense matrix from fill if the function is pure. And that this shortcut is taken before any other fused broadcast:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> map(_ -> rand(), Fill(\"pi\", 2,5))  # not a pure function!\n2×5 Fill{Float64}, with entries equal to 0.32597672886359486\n\njulia> map(_ -> rand(), fill(\"4\", 2,5))  # 10 evaluations, different answer!\n2×5 Matrix{Float64}:\n 0.549051  0.894245  0.394255  0.795547  0.748415\n 0.218587  0.353112  0.953125  0.49425   0.578232\n\njulia> ones(1,5) .+ (_ -> rand()).(Fill(\"vec\", 2))  # Fill broadcast is done first\n2×5 Matrix{Float64}:\n 1.72794  1.72794  1.72794  1.72794  1.72794\n 1.72794  1.72794  1.72794  1.72794  1.72794\n\njulia> ones(1,5) .+ (_ -> rand()).(fill(\"vec\", 2))  # fused, 10 evaluations\n2×5 Matrix{Float64}:\n 1.00745  1.43924  1.95674  1.99667  1.11008\n 1.19938  1.68253  1.64786  1.74919  1.49138","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"#FillArrays.FillArrays","page":"Home","title":"FillArrays.FillArrays","text":"FillArrays module to lazily represent matrices with a single value \n\n\n\n\n\n","category":"module"},{"location":"#FillArrays.AbstractFill","page":"Home","title":"FillArrays.AbstractFill","text":"AbstractFill{T, N, Axes} <: AbstractArray{T, N}\n\nSupertype for lazy array types whose entries are all equal. Subtypes of AbstractFill should implement FillArrays.getindex_value to return the value of the entries.\n\n\n\n\n\n","category":"type"},{"location":"#FillArrays.Falses","page":"Home","title":"FillArrays.Falses","text":"Falses = Zeros{Bool, N, Axes}\n\nLazy version of falses with axes.\n\nSee also: Trues\n\n\n\n\n\n","category":"type"},{"location":"#FillArrays.Fill","page":"Home","title":"FillArrays.Fill","text":"Fill{T, N, Axes} where {T,N,Axes<:Tuple{Vararg{AbstractUnitRange,N}}}\n\nA lazy representation of an array of dimension N whose entries are all equal to a constant of type T, with axes of type Axes. Typically created by Fill or Zeros or Ones\n\nExamples\n\njulia> Fill(7, (2,3))\n2×3 Fill{Int64}, with entries equal to 7\n\njulia> Fill{Float64, 1, Tuple{UnitRange{Int64}}}(7.0, (1:2,))\n2-element Fill{Float64, 1, Tuple{UnitRange{Int64}}} with indices 1:2, with entries equal to 7.0\n\n\n\n\n\n","category":"type"},{"location":"#FillArrays.Fill-Union{Tuple{N}, Tuple{T}, Tuple{T, NTuple{N, Any}}} where {T, N}","page":"Home","title":"FillArrays.Fill","text":"Fill(x, dims) construct lazy version of fill(x, dims) \n\n\n\n\n\n","category":"method"},{"location":"#FillArrays.Fill-Union{Tuple{N}, Tuple{T}, Tuple{T, Vararg{Integer, N}}} where {T, N}","page":"Home","title":"FillArrays.Fill","text":"Fill(x, dims...) construct lazy version of fill(x, dims...) \n\n\n\n\n\n","category":"method"},{"location":"#FillArrays.OneElement","page":"Home","title":"FillArrays.OneElement","text":"OneElement(val, ind, axesorsize) <: AbstractArray\n\nRepresents an array with the specified axes (if its a tuple of AbstractUnitRanges) or size (if its a tuple of Integers), with a single entry set to val and all others equal to zero, specified by ind`.\n\n\n\n\n\n","category":"type"},{"location":"#FillArrays.OneElement-Tuple{Any, Int64, Integer}","page":"Home","title":"FillArrays.OneElement","text":"OneElement(val, ind::Int, n::Integer)\n\nCreates a length n vector where the ind entry is equal to val, and all other entries are zero.\n\n\n\n\n\n","category":"method"},{"location":"#FillArrays.OneElement-Tuple{Int64, Integer}","page":"Home","title":"FillArrays.OneElement","text":"OneElement(ind::Int, n::Integer)\n\nCreates a length n vector where the ind entry is equal to 1, and all other entries are zero.\n\n\n\n\n\n","category":"method"},{"location":"#FillArrays.OneElement-Union{Tuple{T}, Tuple{Int64, Integer}} where T","page":"Home","title":"FillArrays.OneElement","text":"OneElement{T}(ind::Int, n::Int)\n\nCreates a length n vector where the ind entry is equal to one(T), and all other entries are zero.\n\n\n\n\n\n","category":"method"},{"location":"#FillArrays.Ones","page":"Home","title":"FillArrays.Ones","text":"Ones{T, N, Axes} <: AbstractFill{T, N, Axes} (lazy ones with axes)\n\n\n\n\n\n","category":"type"},{"location":"#FillArrays.Ones-Union{NTuple{N, Integer}, Tuple{N}, Tuple{T}} where {T, N}","page":"Home","title":"FillArrays.Ones","text":"Ones{T}(dims...) construct lazy version of ones(dims...)\n\n\n\n\n\n","category":"method"},{"location":"#FillArrays.Trues","page":"Home","title":"FillArrays.Trues","text":"Trues = Ones{Bool, N, Axes} where {N, Axes}\n\nLazy version of trues with axes. Typically created using Trues(dims) or Trues(dims...)\n\nExample\n\njulia> T = Trues(1,3)\n1×3 Ones{Bool}\n\njulia> Array(T)\n1×3 Matrix{Bool}:\n 1  1  1\n\n\n\n\n\n","category":"type"},{"location":"#FillArrays.Zeros","page":"Home","title":"FillArrays.Zeros","text":"Zeros{T, N, Axes} <: AbstractFill{T, N, Axes} (lazy zeros with axes)\n\n\n\n\n\n","category":"type"},{"location":"#FillArrays.Zeros-Union{NTuple{N, Integer}, Tuple{N}, Tuple{T}} where {T, N}","page":"Home","title":"FillArrays.Zeros","text":"Zeros{T}(dims...) construct lazy version of zeros(dims...)\n\n\n\n\n\n","category":"method"},{"location":"#FillArrays.fillsimilar-Union{Tuple{T}, Tuple{Ones{T}, Vararg{Any}}} where T","page":"Home","title":"FillArrays.fillsimilar","text":"fillsimilar(a::AbstractFill, axes...)\n\ncreates a fill object that has the same fill value as a but with the specified axes. For example, if a isa Zeros then so is the returned object.\n\n\n\n\n\n","category":"method"},{"location":"#FillArrays.getindex_value","page":"Home","title":"FillArrays.getindex_value","text":"FillArrays.getindex_value(F::AbstractFill)\n\nReturn the value that F is filled with.\n\nExamples\n\njulia> f = Ones(3);\n\njulia> FillArrays.getindex_value(f)\n1.0\n\njulia> g = Fill(2, 10);\n\njulia> FillArrays.getindex_value(g)\n2\n\n\n\n\n\n","category":"function"},{"location":"#FillArrays.getindex_value-Tuple{OneElement}","page":"Home","title":"FillArrays.getindex_value","text":"getindex_value(A::OneElement)\n\nReturn the only non-zero value stored in A.\n\nnote: Note\nIf the index at which the value is stored doesn't lie within the valid indices of A, then this returns zero(eltype(A)).\n\nExamples\n\njulia> A = OneElement(2, 3)\n3-element OneElement{Int64, 1, Tuple{Int64}, Tuple{Base.OneTo{Int64}}}:\n ⋅\n 1\n ⋅\n\njulia> FillArrays.getindex_value(A)\n1\n\n\n\n\n\n","category":"method"},{"location":"#FillArrays.nzind-Tuple{OneElement}","page":"Home","title":"FillArrays.nzind","text":"nzind(A::OneElement{T,N}) -> CartesianIndex{N}\n\nReturn the index where A contains a non-zero value.\n\nnote: Note\nThe indices are not guaranteed to lie within the valid index bounds for A, and if FillArrays.nzind(A) ∉ CartesianIndices(A) then all(iszero, A). On the other hand, if FillArrays.nzind(A) in CartesianIndices(A) then A[FillArrays.nzind(A)] == FillArrays.getindex_value(A)\n\nExamples\n\njulia> A = OneElement(2, (1,2), (2,2))\n2×2 OneElement{Int64, 2, Tuple{Int64, Int64}, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}:\n ⋅  2\n ⋅  ⋅\n\njulia> FillArrays.nzind(A)\nCartesianIndex(1, 2)\n\njulia> A[FillArrays.nzind(A)]\n2\n\n\n\n\n\n","category":"method"},{"location":"#FillArrays.unique_value-Tuple{AbstractArray}","page":"Home","title":"FillArrays.unique_value","text":"unique_value(arr::AbstractArray)\n\nReturn only(unique(arr)) without intermediate allocations. Throws an error if arr does not contain one and only one unique value.\n\n\n\n\n\n","category":"method"}]
}
